/** \brief AUTOSAR Gpt GPT Driver
 **
 ** This file contains the implementation of the AUTOSAR module Gpt
 ** for interruptions.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL40-DRV
 **
 ** (c) 2014-2017, Cypress Semiconductor Corporation. All rights reserved.
 **
 ** Warranty and Disclaimer
 **
 ** This software product is property of Cypress Semiconductor Corporation or
 ** its subsidiaries.
 ** Any use and/or distribution rights for this software product are provided
 ** only under the Cypress Software License Agreement.
 ** Any use and/or distribution of this software product not in accordance with
 ** the terms of the Cypress Software License Agreement are unauthorized and
 ** shall constitute an infringement of Cypress intellectual property rights.
*/

/*==================[inclusions]============================================*/
/* PRQA S 857 EOF *//* Reason for disabling: Because the number of registers is large, more than 1024 macro is necessary. */
#include <Gpt.h>
#include <Os.h>
#if (GPT_REPORT_WAKEUP_SOURCE == STD_ON)
#include <EcuM.h>
#endif
#include <Gpt_Controller.h>
#include <Gpt_Status.h>
#include <Gpt_IrqClear_Der.h>
#include <Gpt_External.h>
/*==================[macros]================================================*/
/*==================[type definitions]======================================*/
/*==================[external function declarations]========================*/
/*==================[internal function declarations]========================*/
#define GPT_START_SEC_CODE
#include <MemMap.h>

/** \brief Gpt_IsrVector176_Internal()
 **
 ** Internal Gpt interrupt service routine for FRT_0.
 **
 */
TS_STATIC_FUNC FUNC(void, GPT_CODE) Gpt_IsrVector176_Internal(void);

/** \brief Gpt_IsrVector177_Internal()
 **
 ** Internal Gpt interrupt service routine for FRT_1.
 **
 */
TS_STATIC_FUNC FUNC(void, GPT_CODE) Gpt_IsrVector177_Internal(void);

/** \brief Gpt_IsrVector179_Internal()
 **
 ** Internal Gpt interrupt service routine for FRT_3.
 **
 */
TS_STATIC_FUNC FUNC(void, GPT_CODE) Gpt_IsrVector179_Internal(void);

/** \brief Gpt_IsrVector180_Internal()
 **
 ** Internal Gpt interrupt service routine for FRT_4.
 **
 */
TS_STATIC_FUNC FUNC(void, GPT_CODE) Gpt_IsrVector180_Internal(void);

/** \brief Gpt_IsrVector168_Internal()
 **
 ** Internal Gpt interrupt service routine for RLT_32.
 **
 */
TS_STATIC_FUNC FUNC(void, GPT_CODE) Gpt_IsrVector168_Internal(void);

/** \brief Gpt_IsrVector169_Internal()
 **
 ** Internal Gpt interrupt service routine for RLT_33.
 **
 */
TS_STATIC_FUNC FUNC(void, GPT_CODE) Gpt_IsrVector169_Internal(void);

/** \brief Gpt_IsrVector170_Internal()
 **
 ** Internal Gpt interrupt service routine for RLT_34.
 **
 */
TS_STATIC_FUNC FUNC(void, GPT_CODE) Gpt_IsrVector170_Internal(void);

#define GPT_STOP_SEC_CODE
/* PRQA S 5087 1 *//* This inclusion is required by AUTOSAR specification. */
#include <MemMap.h>

/*==================[external constants]====================================*/
/*==================[internal constants]====================================*/
/*==================[external data]=========================================*/
/*==================[internal data]=========================================*/
#ifdef __MCAL_IO_DEFINE
#define GPT_START_SEC_VAR_NO_INIT_UNSPECIFIED
/* PRQA S 5087 1 *//* This inclusion is required by AUTOSAR specification. */
#include <MemMap.h>

TS_STATIC_VAR VAR(uint32, GPT_DATA) Gpt_IrcUnlockRegister;
TS_STATIC_VAR VAR(uint32, GPT_DATA) Gpt_IrcCsrRegister;
TS_STATIC_VAR VAR(uint32, GPT_DATA) Gpt_IrqhcRegister;

#define GPT_STOP_SEC_VAR_NO_INIT_UNSPECIFIED
/* PRQA S 5087 1 *//* This inclusion is required by AUTOSAR specification. */
#include <MemMap.h>
#endif

/*==================[external function definitions]=========================*/
/* Interrupt service routines.
 *
 * These interrupt service routines are generated assuming that the driver
 * will be running under the AutosarOs. If this is not the case, an ISR
 * macro must be provided.
*/
#define GPT_START_SEC_CODE
/* PRQA S 5087 1 *//* This inclusion is required by AUTOSAR specification. */
#include <MemMap.h>

/** \brief GPT_ISR_Vector_176_CAT1()
 **
 ** Gpt interrupt service routine (Cat1):
 ** Entry point for FRT_0's interrupt vector 176.
 **
 */
ISR_NATIVE(GPT_ISR_Vector_176_CAT1)
{
  Gpt_IsrVector176_Internal();
  /* PRQA S 303 1 *//* Reason for disabling: It is a necessary for HW access. */
  Gpt_ResetIrqrPendingFlag(GPT_IRC_IRQHC_ADDR, 176U);
}

/** \brief GPT_ISR_Vector_176_CAT2()
 **
 ** Gpt interrupt service routine (Cat2):
 ** Entry point for FRT_0's interrupt vector 176.
 **
 */
ISR(GPT_ISR_Vector_176_CAT2)
{
  Gpt_IsrVector176_Internal();
}

/** \brief GPT_ISR_Vector_177_CAT1()
 **
 ** Gpt interrupt service routine (Cat1):
 ** Entry point for FRT_1's interrupt vector 177.
 **
 */
ISR_NATIVE(GPT_ISR_Vector_177_CAT1)
{
  Gpt_IsrVector177_Internal();
  /* PRQA S 303 1 *//* Reason for disabling: It is a necessary for HW access. */
  Gpt_ResetIrqrPendingFlag(GPT_IRC_IRQHC_ADDR, 177U);
}

/** \brief GPT_ISR_Vector_177_CAT2()
 **
 ** Gpt interrupt service routine (Cat2):
 ** Entry point for FRT_1's interrupt vector 177.
 **
 */
ISR(GPT_ISR_Vector_177_CAT2)
{
  Gpt_IsrVector177_Internal();
}

/** \brief GPT_ISR_Vector_179_CAT1()
 **
 ** Gpt interrupt service routine (Cat1):
 ** Entry point for FRT_3's interrupt vector 179.
 **
 */
ISR_NATIVE(GPT_ISR_Vector_179_CAT1)
{
  Gpt_IsrVector179_Internal();
  /* PRQA S 303 1 *//* Reason for disabling: It is a necessary for HW access. */
  Gpt_ResetIrqrPendingFlag(GPT_IRC_IRQHC_ADDR, 179U);
}

/** \brief GPT_ISR_Vector_179_CAT2()
 **
 ** Gpt interrupt service routine (Cat2):
 ** Entry point for FRT_3's interrupt vector 179.
 **
 */
ISR(GPT_ISR_Vector_179_CAT2)
{
  Gpt_IsrVector179_Internal();
}

/** \brief GPT_ISR_Vector_180_CAT1()
 **
 ** Gpt interrupt service routine (Cat1):
 ** Entry point for FRT_4's interrupt vector 180.
 **
 */
ISR_NATIVE(GPT_ISR_Vector_180_CAT1)
{
  Gpt_IsrVector180_Internal();
  /* PRQA S 303 1 *//* Reason for disabling: It is a necessary for HW access. */
  Gpt_ResetIrqrPendingFlag(GPT_IRC_IRQHC_ADDR, 180U);
}

/** \brief GPT_ISR_Vector_180_CAT2()
 **
 ** Gpt interrupt service routine (Cat2):
 ** Entry point for FRT_4's interrupt vector 180.
 **
 */
ISR(GPT_ISR_Vector_180_CAT2)
{
  Gpt_IsrVector180_Internal();
}

/** \brief GPT_ISR_Vector_168_CAT1()
 **
 ** Gpt interrupt service routine (Cat1):
 ** Entry point for RLT_32's interrupt vector 168.
 **
 */
ISR_NATIVE(GPT_ISR_Vector_168_CAT1)
{
  Gpt_IsrVector168_Internal();
  /* PRQA S 303 1 *//* Reason for disabling: It is a necessary for HW access. */
  Gpt_ResetIrqrPendingFlag(GPT_IRC_IRQHC_ADDR, 168U);
}

/** \brief GPT_ISR_Vector_168_CAT2()
 **
 ** Gpt interrupt service routine (Cat2):
 ** Entry point for RLT_32's interrupt vector 168.
 **
 */
ISR(GPT_ISR_Vector_168_CAT2)
{
  Gpt_IsrVector168_Internal();
}

/** \brief GPT_ISR_Vector_169_CAT1()
 **
 ** Gpt interrupt service routine (Cat1):
 ** Entry point for RLT_33's interrupt vector 169.
 **
 */
ISR_NATIVE(GPT_ISR_Vector_169_CAT1)
{
  Gpt_IsrVector169_Internal();
  /* PRQA S 303 1 *//* Reason for disabling: It is a necessary for HW access. */
  Gpt_ResetIrqrPendingFlag(GPT_IRC_IRQHC_ADDR, 169U);
}

/** \brief GPT_ISR_Vector_169_CAT2()
 **
 ** Gpt interrupt service routine (Cat2):
 ** Entry point for RLT_33's interrupt vector 169.
 **
 */
ISR(GPT_ISR_Vector_169_CAT2)
{
  Gpt_IsrVector169_Internal();
}

/** \brief GPT_ISR_Vector_170_CAT1()
 **
 ** Gpt interrupt service routine (Cat1):
 ** Entry point for RLT_34's interrupt vector 170.
 **
 */
ISR_NATIVE(GPT_ISR_Vector_170_CAT1)
{
  Gpt_IsrVector170_Internal();
  /* PRQA S 303 1 *//* Reason for disabling: It is a necessary for HW access. */
  Gpt_ResetIrqrPendingFlag(GPT_IRC_IRQHC_ADDR, 170U);
}

/** \brief GPT_ISR_Vector_170_CAT2()
 **
 ** Gpt interrupt service routine (Cat2):
 ** Entry point for RLT_34's interrupt vector 170.
 **
 */
ISR(GPT_ISR_Vector_170_CAT2)
{
  Gpt_IsrVector170_Internal();
}

#define GPT_STOP_SEC_CODE
/* PRQA S 5087 1 *//* This inclusion is required by AUTOSAR specification. */
#include <MemMap.h>

/*==================[internal function definitions]=========================*/
#define GPT_START_SEC_CODE
/* PRQA S 5087 1 *//* This inclusion is required by AUTOSAR specification. */
#include <MemMap.h>


/** \brief Gpt_IsrVector176_Internal()
 **
 ** Internal Gpt interrupt service routine for FRT_0.
 **
 */
TS_STATIC_FUNC FUNC(void, GPT_CODE) Gpt_IsrVector176_Internal(void)
{
  if( Gpt_Arch_GetInterruptFlag(GptConf_GptChannelConfiguration_GptChCfg_60MHzFRT) == GPT_OK )
  {
    if ( Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE )
    {
      Gpt_ReportError(GPT_TIMEREXPIRE, GPT_E_INTERNAL);
    }
    else
    {
      if( Gpt_Arch_TimerExpire(GptConf_GptChannelConfiguration_GptChCfg_60MHzFRT) == GPT_OK )
      {
#if (GPT_REPORT_WAKEUP_SOURCE == STD_ON)
        EcuM_CheckWakeup(0x00000000U);
#endif
      }
    }
  } else
  {
    /* not action */
  }
}

/** \brief Gpt_IsrVector177_Internal()
 **
 ** Internal Gpt interrupt service routine for FRT_1.
 **
 */
TS_STATIC_FUNC FUNC(void, GPT_CODE) Gpt_IsrVector177_Internal(void)
{
  if( Gpt_Arch_GetInterruptFlag(GptConf_GptChannelConfiguration_Rtm_FRT) == GPT_OK )
  {
    if ( Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE )
    {
      Gpt_ReportError(GPT_TIMEREXPIRE, GPT_E_INTERNAL);
    }
    else
    {
      if( Gpt_Arch_TimerExpire(GptConf_GptChannelConfiguration_Rtm_FRT) == GPT_OK )
      {
#if (GPT_REPORT_WAKEUP_SOURCE == STD_ON)
        EcuM_CheckWakeup(0x00000000U);
#endif
      }
    }
  } else
  {
    /* not action */
  }
}

/** \brief Gpt_IsrVector179_Internal()
 **
 ** Internal Gpt interrupt service routine for FRT_3.
 **
 */
TS_STATIC_FUNC FUNC(void, GPT_CODE) Gpt_IsrVector179_Internal(void)
{
  if( Gpt_Arch_GetInterruptFlag(GptConf_GptChannelConfiguration_StpCdd) == GPT_OK )
  {
    if ( Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE )
    {
      Gpt_ReportError(GPT_TIMEREXPIRE, GPT_E_INTERNAL);
    }
    else
    {
      if( Gpt_Arch_TimerExpire(GptConf_GptChannelConfiguration_StpCdd) == GPT_OK )
      {
#if (GPT_REPORT_WAKEUP_SOURCE == STD_ON)
        EcuM_CheckWakeup(0x00000000U);
#endif
      }
    }
  } else
  {
    /* not action */
  }
}

/** \brief Gpt_IsrVector180_Internal()
 **
 ** Internal Gpt interrupt service routine for FRT_4.
 **
 */
TS_STATIC_FUNC FUNC(void, GPT_CODE) Gpt_IsrVector180_Internal(void)
{
  if( Gpt_Arch_GetInterruptFlag(GptConf_GptChannelConfiguration_TmExt) == GPT_OK )
  {
    if ( Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE )
    {
      Gpt_ReportError(GPT_TIMEREXPIRE, GPT_E_INTERNAL);
    }
    else
    {
      if( Gpt_Arch_TimerExpire(GptConf_GptChannelConfiguration_TmExt) == GPT_OK )
      {
#if (GPT_REPORT_WAKEUP_SOURCE == STD_ON)
        EcuM_CheckWakeup(0x00000000U);
#endif
      }
    }
  } else
  {
    /* not action */
  }
}

/** \brief Gpt_IsrVector168_Internal()
 **
 ** Internal Gpt interrupt service routine for RLT_32.
 **
 */
TS_STATIC_FUNC FUNC(void, GPT_CODE) Gpt_IsrVector168_Internal(void)
{
  if( Gpt_Arch_GetInterruptFlag(GptConf_GptChannelConfiguration_Wdg_TO) == GPT_OK )
  {
    if ( Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE )
    {
      Gpt_ReportError(GPT_TIMEREXPIRE, GPT_E_INTERNAL);
    }
    else
    {
      if( Gpt_Arch_TimerExpire(GptConf_GptChannelConfiguration_Wdg_TO) == GPT_OK )
      {
#if (GPT_REPORT_WAKEUP_SOURCE == STD_ON)
        EcuM_CheckWakeup(0x00000000U);
#endif
      }
    }
  } else
  {
    /* not action */
  }
}

/** \brief Gpt_IsrVector169_Internal()
 **
 ** Internal Gpt interrupt service routine for RLT_33.
 **
 */
TS_STATIC_FUNC FUNC(void, GPT_CODE) Gpt_IsrVector169_Internal(void)
{
  if( Gpt_Arch_GetInterruptFlag(GptConf_GptChannelConfiguration_Wdg_Trg) == GPT_OK )
  {
    if ( Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE )
    {
      Gpt_ReportError(GPT_TIMEREXPIRE, GPT_E_INTERNAL);
    }
    else
    {
      if( Gpt_Arch_TimerExpire(GptConf_GptChannelConfiguration_Wdg_Trg) == GPT_OK )
      {
#if (GPT_REPORT_WAKEUP_SOURCE == STD_ON)
        EcuM_CheckWakeup(0x00000000U);
#endif
      }
    }
  } else
  {
    /* not action */
  }
}

/** \brief Gpt_IsrVector170_Internal()
 **
 ** Internal Gpt interrupt service routine for RLT_34.
 **
 */
TS_STATIC_FUNC FUNC(void, GPT_CODE) Gpt_IsrVector170_Internal(void)
{
  if( Gpt_Arch_GetInterruptFlag(GptConf_GptChannelConfiguration_OsTickTimer) == GPT_OK )
  {
    if ( Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE )
    {
      Gpt_ReportError(GPT_TIMEREXPIRE, GPT_E_INTERNAL);
    }
    else
    {
      if( Gpt_Arch_TimerExpire(GptConf_GptChannelConfiguration_OsTickTimer) == GPT_OK )
      {
#if (GPT_REPORT_WAKEUP_SOURCE == STD_ON)
        EcuM_CheckWakeup(0x00000000U);
#endif
      }
    }
  } else
  {
    /* not action */
  }
}

#define GPT_STOP_SEC_CODE
/* PRQA S 5087 1 *//* This inclusion is required by AUTOSAR specification. */
#include <MemMap.h>

/*==================[end of file]===========================================*/
