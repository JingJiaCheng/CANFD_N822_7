/** \brief AUTOSAR Fls Flash Driver
 **
 ** This file contains all definitions of the configuration of the
 ** AUTOSAR module Fls that are target independent.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL40-DRV
 **
 ** (c) 2014-2017, Cypress Semiconductor Corporation. All rights reserved.
 **
 ** Warranty and Disclaimer
 **
 ** This software product is property of Cypress Semiconductor Corporation or
 ** its subsidiaries.
 ** Any use and/or distribution rights for this software product are provided
 ** only under the Cypress Software License Agreement.
 ** Any use and/or distribution of this software product not in accordance with
 ** the terms of the Cypress Software License Agreement are unauthorized and
 ** shall constitute an infringement of Cypress intellectual property rights.
*/

/*==================[inclusions]============================================*/

#include <Fls.h>                /* Fls Flash Driver header file */
#include <Fls_LibInterface.h>   /* Library interface header file */

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

/*==================[external constants]====================================*/

#define FLS_START_SEC_CONST_UNSPECIFIED
/* PRQA S 5087 1 *//* This inclusion is required by AUTOSAR specification. */
#include <MemMap.h>

/* PRQA S 3218 1 *//* This is defined at file scope in order to assist in reading. */
TS_STATIC_VAR CONST( Fls_ConfigType, FLS_CONST ) Fls_Config =
{
  FLS_TOTAL_SIZE,                                              /* TotalSize;           */
  (sint32)10,                         /* CallCycle            */

  &Fee_JobEndNotification,               /* JobEndNotifFctPtr;   */

  &Fee_JobErrorNotification,             /* JobErrorNotifFctPtr  */
  128UL,        /* MaxReadNormalMode;   */
  1024UL,          /* MaxReadFastMode;     */
  0UL,                                                         /* MaxWriteNormalMode;  */
  0UL,                                                         /* MaxWriteFastMode;    */
  FLS_PAGE_SIZE,                                               /* PageSize             */
  FLS_NUMBER_OF_SECTORS,                                       /* NumberOfSectors;     */
  FLS_VERIFICATION_FLAG,                                       /* VerificationFlag     */
  FLS_SECTOR_SIZE,                                             /* SectorSize           */
  FLS_ERASE_TIME,                                              /* EraseTime            */
  MEMIF_MODE_SLOW                        /* DefaultMode          */
};

/* PRQA S 3218 1 *//* This is defined at file scope in order to assist in reading. */
TS_STATIC_VAR CONST( Fls_MemoryMapType, FLS_CONST ) Fls_MemoryMap[FLS_NUMBER_OF_SECTORS] =
{
  /* logical start address                                                                 */
  /*  |       length of sector                                                             */
  /*  |           |       sector address for operations                                    */
  /*  |           |           |                                                            */
  /*  V           V           V                                                            */
      {0x0U,0x2000U,0xe000000U},
      {0x2000U,0x2000U,0xe002000U},
      {0x4000U,0x2000U,0xe004000U},
      {0x6000U,0x2000U,0xe006000U},
      {0x8000U,0x2000U,0xe008000U},
      {0xa000U,0x2000U,0xe00a000U},
      {0xc000U,0x2000U,0xe00c000U},
      {0xe000U,0x2000U,0xe00e000U},
      {0x10000U,0x2000U,0xe010000U},
      {0x12000U,0x2000U,0xe012000U},
      {0x14000U,0x2000U,0xe014000U},
      {0x16000U,0x2000U,0xe016000U},
      {0x18000U,0x2000U,0xe018000U},
      {0x1a000U,0x2000U,0xe01a000U}
};

#define FLS_STOP_SEC_CONST_UNSPECIFIED
/* PRQA S 5087 1 *//* This inclusion is required by AUTOSAR specification. */
#include <MemMap.h>

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

#if defined( __MCAL_IO_DEFINE )

#define FLS_START_SEC_VAR_NO_INIT_UNSPECIFIED
/* PRQA S 5087 1 *//* This inclusion is required by AUTOSAR specification. */
#include <MemMap.h>

TS_STATIC_VAR uint32 Fls_DummyRegArea[FLS_DUMMY_REGAREA_SIZE >> 2];

uint8 Fls_DummyFlash[FLS_NUMBER_OF_SECTORS * FLS_SECTOR_SIZE];

#define FLS_STOP_SEC_VAR_NO_INIT_UNSPECIFIED
/* PRQA S 5087 1 *//* This inclusion is required by AUTOSAR specification. */
#include <MemMap.h>

#endif /* if defined( __MCAL_IO_DEFINE ) */

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

#define FLS_START_SEC_CODE
/* PRQA S 5087 1 *//* This inclusion is required by AUTOSAR specification. */
#include <MemMap.h>

/** \brief Fls_WdgClear
 **
 ** This function is implemented for clearing (triggering) the watchdog timer by user.
 ** 
 ** \return    none
 **
 */
FUNC(void, FLS_CODE) Fls_WdgClear(void)
{
    /* This function is implemented for clearing (triggering) the watchdog timer by user. */

    return;
}

/** \brief Fls_GetConfig
 **
 ** Gets address to configuration.
 **
 ** \return     Configuration address
 **
 */
FUNC_P2CONST(Fls_ConfigType, FLS_APPL_DATA, AUTOMATIC) Fls_GetConfig(void)
{
    const Fls_ConfigType * ConfigPtr;   /* pointer to configuration */

    /* Fls191: store the configuration pointer locally */
    ConfigPtr = &Fls_Config;

    return ConfigPtr;
}

/** \brief Fls_GetMemoryMap
 **
 ** Gets address to memory map.
 **
 ** \return     Memory map address
 **
 */
FUNC_P2CONST(Fls_MemoryMapType, FLS_APPL_DATA, AUTOMATIC) Fls_GetMemoryMap(void)
{
    const Fls_MemoryMapType * MemoryMap;  /* pointer to memory map */

    MemoryMap = (const Fls_MemoryMapType *)&Fls_MemoryMap[0];

    return MemoryMap;
}

/** \brief Fls_GetWfregBaseAddr
 **
 ** Gets WorkFlash registers base address.
 **
 ** \return     WorkFlash registers base address (i.e. WFCFG_CPR register address)
 **
 */
volatile FUNC_P2VAR(uint32, REGSPACE, AUTOMATIC) Fls_GetWfregBaseAddr(void)
{
    /* PRQA S 303 1 *//* This deviation is due to specifying address (volatile object) by integral value directly for device access. */
    return (volatile uint32 *)FLS_WFCFG_BASE_ADDR;
}

/** \brief Fls_GetDmaiR
 **
 ** Gets DMA0_R register address.
 **
 ** \return     DMA0_R register address
 **
 */
volatile FUNC_P2VAR(uint32, REGSPACE, AUTOMATIC) Fls_GetDmaiR(void)
{
    /* PRQA S 303 1 *//* This deviation is due to specifying address (volatile object) by integral value directly for device access. */
    return (volatile uint32 *)FLS_DMA0_R_ADDR;
}

/** \brief Fls_GetDmaiCmicicm
 **
 ** Gets DMA0_CMICICm register address.
 **
 ** \return     DMA0_CMICICm register address
 **
 */
volatile FUNC_P2VAR(uint32, REGSPACE, AUTOMATIC) Fls_GetDmaiCmicicm(void)
{
    /* PRQA S 303 1 *//* This deviation is due to specifying address (volatile object) by integral value directly for device access. */
    return (volatile uint32 *)FLS_DMA0_CMICIC_ADDR;
}

/** \brief Fls_GetDmaiChannelnBaseAddr
 **
 ** Gets DMA Controller Channel Configuration registers base address.
 **
 ** \return     DMA Controller Channel Configuration registers base address (i.e. DMA0_An register address)
 **
 */
volatile FUNC_P2VAR(uint32, REGSPACE, AUTOMATIC) Fls_GetDmaiChannelnBaseAddr(void)
{
    /* PRQA S 303 1 *//* This deviation is due to specifying address (volatile object) by integral value directly for device access. */
    return (volatile uint32 *)(FLS_DMA0_CHANNEL0_BASE_ADDR + (FLS_DMA0_CHANNEL_OFFSET * FLS_DMA_CH));
}

/** \brief Fls_GetDmaiCmchicn
 **
 ** Gets DMA0_CMCHICn register address.
 **
 ** \return     DMA0_CMCHICn register address
 **
 */
volatile FUNC_P2VAR(uint32, REGSPACE, AUTOMATIC) Fls_GetDmaiCmchicn(void)
{
    /* PRQA S 303 1 *//* This deviation is due to specifying address (volatile object) by integral value directly for device access. */
    return (volatile uint32 *)(FLS_DMA0_CMCHIC0_BASE_ADDR + (FLS_DMA0_CMCHIC_OFFSET * FLS_DMA_CH));
}

/** \brief Fls_GetDmaiBnPnValue
 **
 ** Gets value of priority number for DMA transfer.
 **
 ** \return     value of priority number for DMA transfer
 **
 */
FUNC(uint8, FLS_CODE) Fls_GetDmaiBnPnValue(void)
{
    return (uint8)FLS_DMA_CH_PN;
}

/** \brief Fls_GetUseDma
 **
 ** Gets value of FlsUseDma configuration for writing.
 **
 ** \return     value of FlsUseDma configuration for writing
 ** \retval     FLS_TRUE        use of DMA for writing (DMA transfer)
 **             FLS_FALSE       no use of DMA for writing (CPU transfer)
 **
 */
FUNC(uint8,  FLS_CODE) Fls_GetUseDma(void)
{
    return FLS_USE_DMA;
}

/** \brief Fls_GetNumberOfDelayLoop
 **
 ** Gets value of FlsNumberOfDelayLoop configuration for writing.
 **
 ** \return     value of FlsNumberOfDelayLoop configuration for writing
 **
 */
FUNC(uint32, FLS_CODE) Fls_GetNumberOfDelayLoop(void)
{
    return FLS_NUMBER_OF_DELAY_LOOP;
}

#define FLS_STOP_SEC_CODE
/* PRQA S 5087 1 *//* This inclusion is required by AUTOSAR specification. */
#include <MemMap.h>

/*==================[internal function definitions]=========================*/


/*==================[end of file]===========================================*/
