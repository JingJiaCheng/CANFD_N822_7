/** \brief Can_Cfg.h
 **
 ** This generated interface declares PC configuration items.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL40-DRV
 **
 ** (c) 2014-2017, Cypress Semiconductor Corporation. All rights reserved.
 **
 ** Warranty and Disclaimer
 **
 ** This software product is property of Cypress Semiconductor Corporation or
 ** its subsidiaries.
 ** Any use and/or distribution rights for this software product are provided
 ** only under the Cypress Software License Agreement.
 ** Any use and/or distribution of this software product not in accordance with
 ** the terms of the Cypress Software License Agreement are unauthorized and
 ** shall constitute an infringement of Cypress intellectual property rights.
 */

#ifndef CAN_CFG_H_INCLUDED
#define CAN_CFG_H_INCLUDED

/*==================[inclusions]============================================*/

#include <Std_Types.h>
#include <Os.h>
#include <ErrorCalloutHandler.h>

/*==================[macros]================================================*/

/* Deviation from MISRA-C:2004 Rule 19:
   Macro defines an unrecognized code-fragment.
   Justification: The macros defined in this file are initializers to structs.
   They have to be encapsulated in curly-brackets, which make them look like 
   code-fragments, which they are actually not. */
/* PRQA S 3412 EOF*/

/* CanController 0: CanController_0 */

/** Part of the initializer to the constant array of dedicated RX IDs. */
/* Deviation form MISRA-C:2004 Rule 19.4:
   The replacement list of object-like macro 'CAN_CFG_DEDICATED_RX_IDS_0' is not enclosed in ().
   Justification: CAN_CFG_DEDICATED_RX_IDS_x is just a part of a bigger list CAN_CFG_DEDICATED_RX_IDS.
   It cannot be put in brackets. */
/* PRQA S 3452 48 */
#define CAN_CFG_DEDICATED_RX_IDS_0 \
/* Array of uint32 */\
       0x313u,                              /* Array index 0, standard identifier (11 bit) */ \
       0x584u,                              /* Array index 1, standard identifier (11 bit) */ \
       0x310u,                              /* Array index 2, standard identifier (11 bit) */ \
       0x318u,                              /* Array index 3, standard identifier (11 bit) */ \
       0x10bu,                              /* Array index 4, standard identifier (11 bit) */ \
       0x315u,                              /* Array index 5, standard identifier (11 bit) */ \
       0x639u,                              /* Array index 6, standard identifier (11 bit) */ \
       0x221u,                              /* Array index 7, standard identifier (11 bit) */ \
       0x4a0u,                              /* Array index 8, standard identifier (11 bit) */ \
       0x368u,                              /* Array index 9, standard identifier (11 bit) */ \
       0x636u,                              /* Array index 10, standard identifier (11 bit) */ \
       0x142u,                              /* Array index 11, standard identifier (11 bit) */ \
       0x108u,                              /* Array index 12, standard identifier (11 bit) */ \
       0x366u,                              /* Array index 13, standard identifier (11 bit) */ \
       0x151u,                              /* Array index 14, standard identifier (11 bit) */ \
       0x105u,                              /* Array index 15, standard identifier (11 bit) */ \
       0x101u,                              /* Array index 16, standard identifier (11 bit) */ \
       0x364u,                              /* Array index 17, standard identifier (11 bit) */ \
       0x107u,                              /* Array index 18, standard identifier (11 bit) */ \
       0x260u,                              /* Array index 19, standard identifier (11 bit) */ \
       0x243u,                              /* Array index 20, standard identifier (11 bit) */ \
       0x245u,                              /* Array index 21, standard identifier (11 bit) */ \
       0x278u,                              /* Array index 22, standard identifier (11 bit) */ \
       0x280u,                              /* Array index 23, standard identifier (11 bit) */ \
       0x490u,                              /* Array index 24, standard identifier (11 bit) */ \
       0x491u,                              /* Array index 25, standard identifier (11 bit) */ \
       0x246u,                              /* Array index 26, standard identifier (11 bit) */ \
       0x480u,                              /* Array index 27, standard identifier (11 bit) */ \
       0x279u,                              /* Array index 28, standard identifier (11 bit) */ \
       0x271u,                              /* Array index 29, standard identifier (11 bit) */ \
       0x275u,                              /* Array index 30, standard identifier (11 bit) */ \
       0x31au,                              /* Array index 31, standard identifier (11 bit) */ \
       0x31bu,                              /* Array index 32, standard identifier (11 bit) */ \
       0x582u,                              /* Array index 33, standard identifier (11 bit) */ \
       0x123u,                              /* Array index 34, standard identifier (11 bit) */ \
       0x395u,                              /* Array index 35, standard identifier (11 bit) */ \
       0x384u,                              /* Array index 36, standard identifier (11 bit) */ \
       0x530u,                              /* Array index 37, standard identifier (11 bit) */ \
       0x532u,                              /* Array index 38, standard identifier (11 bit) */ \
       0x325u,                              /* Array index 39, standard identifier (11 bit) */ \
       0x1a5u,                              /* Array index 40, standard identifier (11 bit) */ \
       0x361u,                              /* Array index 41, standard identifier (11 bit) */ \
       0x362u,                              /* Array index 42, standard identifier (11 bit) */ \
       0x720u,                              /* Array index 43, standard identifier (11 bit) */ \
       0x7dfu,                              /* Array index 44, standard identifier (11 bit) */ \
    
/** Part of the initializer to the constant array of FIFO filter elements. */
/* Deviation form MISRA-C:2004 Rule 19.4:
   The replacement list of object-like macro 'CAN_CFG_RX_FIFO_FILTERS_0' is not enclosed in ().
   Justification: CAN_CFG_RX_FIFO_FILTERS_x is just a part of a bigger list CAN_CFG_RX_FIFO_FILTERS.
   It cannot be put in brackets. */
/* PRQA S 3452 6 */
#define CAN_CFG_RX_FIFO_FILTERS_0 \
/* Array of Can_ControllerFilterType */\
  /*          CanIdValue of the Can filter.*/\
  /*          VAR(uint32, TYPEDEF) FilterIdValue;*/\
  /*          |            CanFilterMaskValue of the Can filter. */\
  /*          |            VAR(uint32, TYPEDEF) FilterMaskValue; */\
  /*          |            | */\
  /*          V            V */\
  {      0x400u,      0x780u }, /* Array index 0, standard identifier (11 bit), CAN_RX_FIFO0 */ \


/** Part of the initializer to the constant array of HRHs.
    The list must be sorted ascending by buffer index, FIFOs last. */
#define CAN_CFG_HRH_FILTERS_0 \
/* Array of Can_RxHandleMappingType */\
  /* The index of the controller where the HRH is allocated. */\
  /* VAR(Can_ControllerIdType, TYPEDEF) ControllerIndex, */\
  /* |    */\
  /* |    The unique object identifier to identify the Hardware object. */\
  /* |    VAR(Can_HwHandleType, TYPEDEF) RxHwHandle */\
  /* |    |    */\
  /* |    |    The filter index which filter has detected the message. The filter    */\
  /* |    |    index has only 7 bit. The MSB is set for extended messages. With this */\
  /* |    |    index a search to the allocated HRH is possible, if the order of the  */\
  /* |    |    filters in Message RAM is in the order lower CAN IDs first and first  */\
  /* |    |    all standard IDs and then extended IDs. This order have to match to   */\
  /* |    |    the initialization order. */\
  /* |    |    VAR(Can_ControllerRxHandleType, TYPEDEF) RxHandle */\
  /* |    |    |  */\
  /* V    V    V  */\
  { 0u,  0u,  0u}, /* Array index 0, standard filter, CAN_RX_DEDICATED */\
  { 0u,  1u,  1u}, /* Array index 1, standard filter, CAN_RX_DEDICATED */\
  { 0u,  2u,  2u}, /* Array index 2, standard filter, CAN_RX_DEDICATED */\
  { 0u,  3u,  3u}, /* Array index 3, standard filter, CAN_RX_DEDICATED */\
  { 0u,  4u,  4u}, /* Array index 4, standard filter, CAN_RX_DEDICATED */\
  { 0u,  5u,  5u}, /* Array index 5, standard filter, CAN_RX_DEDICATED */\
  { 0u,  6u,  6u}, /* Array index 6, standard filter, CAN_RX_DEDICATED */\
  { 0u,  7u,  7u}, /* Array index 7, standard filter, CAN_RX_DEDICATED */\
  { 0u,  8u,  8u}, /* Array index 8, standard filter, CAN_RX_DEDICATED */\
  { 0u,  9u,  9u}, /* Array index 9, standard filter, CAN_RX_DEDICATED */\
  { 0u, 10u, 10u}, /* Array index 10, standard filter, CAN_RX_DEDICATED */\
  { 0u, 11u, 11u}, /* Array index 11, standard filter, CAN_RX_DEDICATED */\
  { 0u, 12u, 12u}, /* Array index 12, standard filter, CAN_RX_DEDICATED */\
  { 0u, 13u, 13u}, /* Array index 13, standard filter, CAN_RX_DEDICATED */\
  { 0u, 14u, 14u}, /* Array index 14, standard filter, CAN_RX_DEDICATED */\
  { 0u, 15u, 15u}, /* Array index 15, standard filter, CAN_RX_DEDICATED */\
  { 0u, 16u, 16u}, /* Array index 16, standard filter, CAN_RX_DEDICATED */\
  { 0u, 17u, 17u}, /* Array index 17, standard filter, CAN_RX_DEDICATED */\
  { 0u, 18u, 18u}, /* Array index 18, standard filter, CAN_RX_DEDICATED */\
  { 0u, 19u, 19u}, /* Array index 19, standard filter, CAN_RX_DEDICATED */\
  { 0u, 20u, 20u}, /* Array index 20, standard filter, CAN_RX_DEDICATED */\
  { 0u, 21u, 21u}, /* Array index 21, standard filter, CAN_RX_DEDICATED */\
  { 0u, 22u, 22u}, /* Array index 22, standard filter, CAN_RX_DEDICATED */\
  { 0u, 23u, 23u}, /* Array index 23, standard filter, CAN_RX_DEDICATED */\
  { 0u, 24u, 24u}, /* Array index 24, standard filter, CAN_RX_DEDICATED */\
  { 0u, 25u, 25u}, /* Array index 25, standard filter, CAN_RX_DEDICATED */\
  { 0u, 26u, 26u}, /* Array index 26, standard filter, CAN_RX_DEDICATED */\
  { 0u, 27u, 27u}, /* Array index 27, standard filter, CAN_RX_DEDICATED */\
  { 0u, 28u, 28u}, /* Array index 28, standard filter, CAN_RX_DEDICATED */\
  { 0u, 29u, 29u}, /* Array index 29, standard filter, CAN_RX_DEDICATED */\
  { 0u, 30u, 30u}, /* Array index 30, standard filter, CAN_RX_DEDICATED */\
  { 0u, 31u, 31u}, /* Array index 31, standard filter, CAN_RX_DEDICATED */\
  { 0u, 32u, 32u}, /* Array index 32, standard filter, CAN_RX_DEDICATED */\
  { 0u, 33u, 33u}, /* Array index 33, standard filter, CAN_RX_DEDICATED */\
  { 0u, 34u, 34u}, /* Array index 34, standard filter, CAN_RX_DEDICATED */\
  { 0u, 35u, 35u}, /* Array index 35, standard filter, CAN_RX_DEDICATED */\
  { 0u, 37u, 36u}, /* Array index 36, standard filter, CAN_RX_DEDICATED */\
  { 0u, 38u, 37u}, /* Array index 37, standard filter, CAN_RX_DEDICATED */\
  { 0u, 39u, 38u}, /* Array index 38, standard filter, CAN_RX_DEDICATED */\
  { 0u, 40u, 39u}, /* Array index 39, standard filter, CAN_RX_DEDICATED */\
  { 0u, 41u, 40u}, /* Array index 40, standard filter, CAN_RX_DEDICATED */\
  { 0u, 42u, 41u}, /* Array index 41, standard filter, CAN_RX_DEDICATED */\
  { 0u, 43u, 42u}, /* Array index 42, standard filter, CAN_RX_DEDICATED */\
  { 0u, 45u, 43u}, /* Array index 43, standard filter, CAN_RX_DEDICATED */\
  { 0u, 46u, 44u}, /* Array index 44, standard filter, CAN_RX_DEDICATED */\
  { 0u, 44u, 45u}, /* Array index 45, standard filter, CAN_RX_FIFO0 */\



/** Part of the initializer to the constant array of baudrates. */
#define CAN_CFG_BAUDRATES_0 \
/* Array of Can_ControllerBaudrateConfigType */\
  /* The value by which the CAN prescaler output frequency is divided for generating */\
  /* the bit time quanta. (I.e. there is a global CAN prescaler maintained by */\
  /* Can_ModuleManager, and an additional individual prescaler per CAN controller.) */\
  /* The bit time is built up from a multiple of this quanta. */\
  /* Valid values for the Baud Rate Prescaler are 1 to 1024. */\
  /* CONST(uint16, TYPEDEF) NominalBaudratePrescaler; */\
  /*    |      */\
  /*    |      The value of the baudrate in kbps. */\
  /*    |      CONST(uint16, TYPEDEF) BaudrateValue; */\
  /*    |      |    */\
  /*    |      |    (Re) Synchronization Jump Width: Valid values are 1 to 16. */\
  /*    |      |    CONST(uint8, TYPEDEF) SyncJumpWidth; */\
  /*    |      |    |    */\
  /*    |      |    |    Time segment before sample point: Valid values are 2 to 64. */\
  /*    |      |    |    CONST(uint8, TYPEDEF) TSeg1; */\
  /*    |      |    |    |    */\
  /*    |      |    |    |    Time segment after sample point: Valid values are 1 to 16. */\
  /*    |      |    |    |    CONST(uint8, TYPEDEF) TSeg2; */\
  /*    |      |    |    |    |      Switches support of CAN-FD features for this CAN object on or off.           */\
  /*    |      |    |    |    |      TRUE := Valid CAN-FD baudrate settings available and should be used for this */\
  /*    |      |    |    |    |      CAN object.                                                                  */\
  /*    |      |    |    |    |      FALSE := No valid CAN-FD baudrate settings available. Standard CAN should be */\
  /*    |      |    |    |    |      used for this CAN object. */\
  /*    |      |    |    |    |      CONST(boolean, TYPEDEF) FdEnabled; */\
  /*    |      |    |    |    |      |    (Re) Synchronization Jump Width for CAN FD: Valid values are 1 to 16. */\
  /*    |      |    |    |    |      |    CONST(uint8, TYPEDEF) FdSyncJumpWidth; */\
  /*    |      |    |    |    |      |    |    Time segment for CAN FD before sample point: Valid values are 2 to 64. */\
  /*    |      |    |    |    |      |    |    CONST(uint8, TYPEDEF) FdTSeg1; */\
  /*    |      |    |    |    |      |    |    |    Time segment for CAN FD after sample point: Valid values are 1 to 16. */\
  /*    |      |    |    |    |      |    |    |    CONST(uint8, TYPEDEF) FdTSeg2; */\
  /*    |      |    |    |    |      |    |    |    |      Specifies if the bit rate switching shall be used for transmissions. */\
  /*    |      |    |    |    |      |    |    |    |      FALSE := CAN FD frames shall be sent without bit rate switching */\
  /*    |      |    |    |    |      |    |    |    |      TRUE := CAN FD frames shall be sent with bit rate switching */\
  /*    |      |    |    |    |      |    |    |    |      CONST(boolean, TYPEDEF) FdTxBitRateSwitch; */\
  /*    |      |    |    |    |      |    |    |    |      |     Transceiver delay compensation offset for CAN FD in time quanta of the CAN FD */\
  /*    |      |    |    |    |      |    |    |    |      |     clock: Valid values are 0 to 127 (normal range) and 0xFF (compensation is */\
  /*    |      |    |    |    |      |    |    |    |      |     disabled). */\
  /*    |      |    |    |    |      |    |    |    |      |     CONST(uint8, TYPEDEF) FdTrcvDelayCompensationOffset; */\
  /*    |      |    |    |    |      |    |    |    |      |     |      The value by which the CAN prescaler output frequency for Data section if bit */\
  /*    |      |    |    |    |      |    |    |    |      |     |      rate switching is set is divided for generating the bit time quanta. (I.e.    */\
  /*    |      |    |    |    |      |    |    |    |      |     |      there is a global CAN prescaler maintained by Can_ModuleManager, and an       */\
  /*    |      |    |    |    |      |    |    |    |      |     |      additional individual prescaler per CAN controller.) The bit time is built up */\
  /*    |      |    |    |    |      |    |    |    |      |     |      from a multiple of this quanta. */\
  /*    |      |    |    |    |      |    |    |    |      |     |      Valid values for the Baud Rate Prescaler are 1 to 1024. */\
  /*    |      |    |    |    |      |    |    |    |      |     |      CONST(uint16, TYPEDEF) DataBaudratePrescaler; */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |       Unique identifier to identify one baud rate configuration. */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |       Valid range is 0..65535. */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |       CONST(uint16, TYPEDEF) BaudrateConfigId; */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |       |  */\
  /*    V      V    V    V    V      V    V    V    V      V     V      V       V  */\
  {    1u,  500u,  2u, 12u,  3u, FALSE,  0u,  0u,  0u, FALSE, 255u,    1u,     0u }, /* Array index 0; CanFdBaudrateValue:    0; deviation to configured nominal/data baudrate 0.0%/0.0%, deviation to configured TrcvDelayCompensation 0.0% */\

/** Pointer to the base address of the Message RAM. It must point to the hardware
    base address, even if the beginning of the message RAM is not used by this
    controller.
    
    The macro can be overridden by the integrator via command line parameter.
    Doing so is at own risk! */
#ifndef CAN_CFG_MESSAGE_RAM_BASE_PTR_0
  #define CAN_CFG_MESSAGE_RAM_BASE_PTR_0 (P2VAR(uint8, TYPEDEF, TYPEDEF))0xb4918000u
#else
  /* Deviation from MISRA-C:2004 Rule 19.16:
     Unrecognized preprocessing directive has been ignored because of conditional inclusion directives.
     Justification: The preprocessing directive is a warning that indicates a special build 
     configuration which is not suitable for production software. */
  /* PRQA S 3115 1 */
  #warning CAN_CFG_MESSAGE_RAM_BASE_PTR_0 is overridden by the environment. This is not intended for production software!
#endif

/** Base address of the CAN FD controller's registers.
    
    The macro can be overridden by the integrator via command line parameter.
    Doing so is at own risk! */
#ifndef CAN_CFG_REGISTER_BASE_ADDRESS_0
  #define CAN_CFG_REGISTER_BASE_ADDRESS_0 0xb4910000u
#else
  /* Deviation from MISRA-C:2004 Rule 19.16:
     Unrecognized preprocessing directive has been ignored because of conditional inclusion directives.
     Justification: The preprocessing directive is a warning that indicates a special build 
     configuration which is not suitable for production software. */
  /* PRQA S 3115 1 */
  #warning CAN_CFG_REGISTER_BASE_ADDRESS_0 is overridden by the environment. This is not intended for production software!
#endif


/*  Message RAM (0xb4918000) linking table:

    Item                     | Size in elements | Start offset | Size in bytes
    -------------------------+------------------+--------------+--------------
    Standard (11bit) filters |               46 |          0x0 |          0xb8
    Extended (29bit) filters |                0 |         0xb8 |           0x0
    RX FIFO 0                |                8 |         0xb8 |         0x240
    RX FIFO 1                |                0 |        0x2f8 |           0x0
    RX dedicated buffers     |               45 |        0x2f8 |         0xca8
    Event FIFO               |                7 |        0xfa0 |          0x38
    TX dedicated buffers     |                7 |        0xfd8 |         0x1f8
    TX FIFO                  |                0 |       0x11d0 |           0x0
    unused                   |              na. |       0x11d0 |        0x2e2c
 */
    
/** Part of the initializer to the constant array of controllers. */
#define CAN_CFG_CONTROLLER_0 \
{\
  /* Pointer to an array of baudrates. */\
  .BaudratesCfgPtr = &(Can_Baudrates[0u]), /* CONSTP2(Can_ControllerBaudrateConfigType, TYPEDEF, TYPEDEF) */\
  \
  /* Id of the controller. */\
  .ControllerId = 0u, /* CONST(Can_ControllerIdType, TYPEDEF) */\
  \
  /* Pointer to the default baudrate setting. */\
  .DefaultBaudratePtr = &(Can_Baudrates[0u]), /* CONSTP2(Can_ControllerBaudrateConfigType, TYPEDEF, TYPEDEF) */\
  \
  /* Configuration of the TX Event FIFO. The FIFO element size is ignored, because  */\
  /* it is fixed to 8 bytes. */\
  .EventFifo = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 7u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_8, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0xfa0u /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Address offset to the message RAM base address where the filters for extended */\
  /* messages shall be located. */\
  .FiltersExtendedAddressOffset = 0xb8u, /* CONST(uint16, TYPEDEF) */\
  \
  /* Address offset to the message RAM base address where the filters for standard */\
  /* messages shall be located. */\
  .FiltersStandardAddressOffset = 0x0u, /* CONST(uint16, TYPEDEF) */\
  \
  /* Specifies if bus-off handling shall be done in interrupt mode (TRUE) or polling */\
  /* mode (FALSE). */\
  .InterruptEnableBusOff = TRUE, /* CONST(boolean, TYPEDEF) */\
  \
  /* Specifies if RX handling shall be done in interrupt mode (TRUE) or polling mode */\
  /* (FALSE). */\
  .InterruptEnableRx = TRUE, /* CONST(boolean, TYPEDEF) */\
  \
  /* Specifies if TX handling shall be done in interrupt mode (TRUE) or polling mode */\
  /* (FALSE). */\
  .InterruptEnableTx = TRUE, /* CONST(boolean, TYPEDEF) */\
  \
  /* Specifies if wakeup handling shall be done in interrupt mode (TRUE) or polling */\
  /* mode (FALSE). */\
  .InterruptEnableWakeup = TRUE, /* CONST(boolean, TYPEDEF) */\
  \
  /* Pointer to the base address of the Message RAM. It must point to the hardware */\
  /* base address, even if the beginning of the message RAM is not used by this */\
  /* controller. */\
  .MessageRamBasePtr = CAN_CFG_MESSAGE_RAM_BASE_PTR_0, /* CONSTP2VAR(uint8, TYPEDEF, TYPEDEF) */\
  \
  /* Number of baudrates in the array of baudrates pointed to by BaudratesCfgPtr. */\
  .NumberOfBaudrates = 1u, /* CONST(uint8, TYPEDEF) */\
  \
  /* Base address of the CAN FD controller's registers. */\
  .RegisterBaseAddress = CAN_CFG_REGISTER_BASE_ADDRESS_0, /* CONST(uint32, TYPEDEF) */\
  \
  /* Configuration of the dedicated RX buffers. The ElementCount equals the number */\
  /* of filter settings in the filter settings list. */\
  .RxBuffers = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 45u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_64, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0x2f8u /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Pointer to an array of CAN IDs. There is one ID per dedicated RX buffer; the */\
  /* order is the same as the buffers (same index).  */\
  .RxBuffersFiltersPtr = &(Can_DedicatedRxIds[0u]), /* P2CONST(uint32, TYPEDEF, TYPEDEF) */\
  \
  /* Configuration of the RX FIFO 0. */\
  .RxFifo0 = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 8u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_64, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0xb8u /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Pointer to an array of different Can filter settings for the RX FIFO 0 */\
  .RxFifo0FiltersPtr = &(Can_RxFifoFilters[0]), /* P2CONST(Can_ControllerFilterType, TYPEDEF, TYPEDEF) */\
  \
  /* Number of RxFifo0 filters stored in array RxFifo0FiltersPtr. */\
  .RxFifo0FilterElementCount = 1u, /* CONST(uint8, TYPEDEF) */\
  /* Configuration of the RX FIFO 1. */\
  .RxFifo1 = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 0u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_64, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0x2f8u /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Pointer to an array of different Can filter settings for the RX FIFO 1 */\
  .RxFifo1FiltersPtr = (P2CONST(Can_ControllerFilterType, AUTOMATIC, AUTOMATIC))NULL_PTR, /* P2CONST(Can_ControllerFilterType, TYPEDEF, TYPEDEF) */\
  \
  /* Number of RxFifo1 filters stored in array RxFifo1FiltersPtr. */\
  .RxFifo1FilterElementCount = 0u, /* CONST(uint8, TYPEDEF) */\
  /* Configuration of the dedicated TX buffers. */\
  .TxBuffers = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 7u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_64, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0xfd8u /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Configuration of the TX FIFO element count. The FIFO element size and start */\
  /* offset are shared with the dedicated TX Buffers. */\
  .TxFifoElementCount = 0u, /* CONST(uint8, TYPEDEF) */\
  \
  /* The wakeup source id that is passed to EcuM_CheckWakeup. */\
  .WakeupSource = 1uL << 5u /* CONST(uint32, TYPEDEF) */\
},\

/* CanController 1: CanController_1 */

/** Part of the initializer to the constant array of dedicated RX IDs. */
/* Deviation form MISRA-C:2004 Rule 19.4:
   The replacement list of object-like macro 'CAN_CFG_DEDICATED_RX_IDS_0' is not enclosed in ().
   Justification: CAN_CFG_DEDICATED_RX_IDS_x is just a part of a bigger list CAN_CFG_DEDICATED_RX_IDS.
   It cannot be put in brackets. */
/* PRQA S 3452 4 */
#define CAN_CFG_DEDICATED_RX_IDS_1 \
/* Array of uint32 */\
       0x382u,                              /* Array index 45, standard identifier (11 bit) */ \
    
/** Part of the initializer to the constant array of FIFO filter elements. */
/* Deviation form MISRA-C:2004 Rule 19.4:
   The replacement list of object-like macro 'CAN_CFG_RX_FIFO_FILTERS_0' is not enclosed in ().
   Justification: CAN_CFG_RX_FIFO_FILTERS_x is just a part of a bigger list CAN_CFG_RX_FIFO_FILTERS.
   It cannot be put in brackets. */
/* PRQA S 3452 5 */
#define CAN_CFG_RX_FIFO_FILTERS_1 \
/* Array of Can_ControllerFilterType */\
  /*          CanIdValue of the Can filter.*/\
  /*          VAR(uint32, TYPEDEF) FilterIdValue;*/\
  /*          |            CanFilterMaskValue of the Can filter. */\
  /*          |            VAR(uint32, TYPEDEF) FilterMaskValue; */\
  /*          |            | */\
  /*          V            V */\


/** Part of the initializer to the constant array of HRHs.
    The list must be sorted ascending by buffer index, FIFOs last. */
#define CAN_CFG_HRH_FILTERS_1 \
/* Array of Can_RxHandleMappingType */\
  /* The index of the controller where the HRH is allocated. */\
  /* VAR(Can_ControllerIdType, TYPEDEF) ControllerIndex, */\
  /* |    */\
  /* |    The unique object identifier to identify the Hardware object. */\
  /* |    VAR(Can_HwHandleType, TYPEDEF) RxHwHandle */\
  /* |    |    */\
  /* |    |    The filter index which filter has detected the message. The filter    */\
  /* |    |    index has only 7 bit. The MSB is set for extended messages. With this */\
  /* |    |    index a search to the allocated HRH is possible, if the order of the  */\
  /* |    |    filters in Message RAM is in the order lower CAN IDs first and first  */\
  /* |    |    all standard IDs and then extended IDs. This order have to match to   */\
  /* |    |    the initialization order. */\
  /* |    |    VAR(Can_ControllerRxHandleType, TYPEDEF) RxHandle */\
  /* |    |    |  */\
  /* V    V    V  */\
  { 1u, 36u,  0u}, /* Array index 46, standard filter, CAN_RX_DEDICATED */\



/** Part of the initializer to the constant array of baudrates. */
#define CAN_CFG_BAUDRATES_1 \
/* Array of Can_ControllerBaudrateConfigType */\
  /* The value by which the CAN prescaler output frequency is divided for generating */\
  /* the bit time quanta. (I.e. there is a global CAN prescaler maintained by */\
  /* Can_ModuleManager, and an additional individual prescaler per CAN controller.) */\
  /* The bit time is built up from a multiple of this quanta. */\
  /* Valid values for the Baud Rate Prescaler are 1 to 1024. */\
  /* CONST(uint16, TYPEDEF) NominalBaudratePrescaler; */\
  /*    |      */\
  /*    |      The value of the baudrate in kbps. */\
  /*    |      CONST(uint16, TYPEDEF) BaudrateValue; */\
  /*    |      |    */\
  /*    |      |    (Re) Synchronization Jump Width: Valid values are 1 to 16. */\
  /*    |      |    CONST(uint8, TYPEDEF) SyncJumpWidth; */\
  /*    |      |    |    */\
  /*    |      |    |    Time segment before sample point: Valid values are 2 to 64. */\
  /*    |      |    |    CONST(uint8, TYPEDEF) TSeg1; */\
  /*    |      |    |    |    */\
  /*    |      |    |    |    Time segment after sample point: Valid values are 1 to 16. */\
  /*    |      |    |    |    CONST(uint8, TYPEDEF) TSeg2; */\
  /*    |      |    |    |    |      Switches support of CAN-FD features for this CAN object on or off.           */\
  /*    |      |    |    |    |      TRUE := Valid CAN-FD baudrate settings available and should be used for this */\
  /*    |      |    |    |    |      CAN object.                                                                  */\
  /*    |      |    |    |    |      FALSE := No valid CAN-FD baudrate settings available. Standard CAN should be */\
  /*    |      |    |    |    |      used for this CAN object. */\
  /*    |      |    |    |    |      CONST(boolean, TYPEDEF) FdEnabled; */\
  /*    |      |    |    |    |      |    (Re) Synchronization Jump Width for CAN FD: Valid values are 1 to 16. */\
  /*    |      |    |    |    |      |    CONST(uint8, TYPEDEF) FdSyncJumpWidth; */\
  /*    |      |    |    |    |      |    |    Time segment for CAN FD before sample point: Valid values are 2 to 64. */\
  /*    |      |    |    |    |      |    |    CONST(uint8, TYPEDEF) FdTSeg1; */\
  /*    |      |    |    |    |      |    |    |    Time segment for CAN FD after sample point: Valid values are 1 to 16. */\
  /*    |      |    |    |    |      |    |    |    CONST(uint8, TYPEDEF) FdTSeg2; */\
  /*    |      |    |    |    |      |    |    |    |      Specifies if the bit rate switching shall be used for transmissions. */\
  /*    |      |    |    |    |      |    |    |    |      FALSE := CAN FD frames shall be sent without bit rate switching */\
  /*    |      |    |    |    |      |    |    |    |      TRUE := CAN FD frames shall be sent with bit rate switching */\
  /*    |      |    |    |    |      |    |    |    |      CONST(boolean, TYPEDEF) FdTxBitRateSwitch; */\
  /*    |      |    |    |    |      |    |    |    |      |     Transceiver delay compensation offset for CAN FD in time quanta of the CAN FD */\
  /*    |      |    |    |    |      |    |    |    |      |     clock: Valid values are 0 to 127 (normal range) and 0xFF (compensation is */\
  /*    |      |    |    |    |      |    |    |    |      |     disabled). */\
  /*    |      |    |    |    |      |    |    |    |      |     CONST(uint8, TYPEDEF) FdTrcvDelayCompensationOffset; */\
  /*    |      |    |    |    |      |    |    |    |      |     |      The value by which the CAN prescaler output frequency for Data section if bit */\
  /*    |      |    |    |    |      |    |    |    |      |     |      rate switching is set is divided for generating the bit time quanta. (I.e.    */\
  /*    |      |    |    |    |      |    |    |    |      |     |      there is a global CAN prescaler maintained by Can_ModuleManager, and an       */\
  /*    |      |    |    |    |      |    |    |    |      |     |      additional individual prescaler per CAN controller.) The bit time is built up */\
  /*    |      |    |    |    |      |    |    |    |      |     |      from a multiple of this quanta. */\
  /*    |      |    |    |    |      |    |    |    |      |     |      Valid values for the Baud Rate Prescaler are 1 to 1024. */\
  /*    |      |    |    |    |      |    |    |    |      |     |      CONST(uint16, TYPEDEF) DataBaudratePrescaler; */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |       Unique identifier to identify one baud rate configuration. */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |       Valid range is 0..65535. */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |       CONST(uint16, TYPEDEF) BaudrateConfigId; */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |       |  */\
  /*    V      V    V    V    V      V    V    V    V      V     V      V       V  */\
  {    1u,  500u,  2u, 12u,  3u, FALSE,  0u,  0u,  0u, FALSE, 255u,    1u,     0u }, /* Array index 1; CanFdBaudrateValue:    0; deviation to configured nominal/data baudrate 0.0%/0.0%, deviation to configured TrcvDelayCompensation 0.0% */\

/** Pointer to the base address of the Message RAM. It must point to the hardware
    base address, even if the beginning of the message RAM is not used by this
    controller.
    
    The macro can be overridden by the integrator via command line parameter.
    Doing so is at own risk! */
#ifndef CAN_CFG_MESSAGE_RAM_BASE_PTR_1
  #define CAN_CFG_MESSAGE_RAM_BASE_PTR_1 (P2VAR(uint8, TYPEDEF, TYPEDEF))0xb06d8000u
#else
  /* Deviation from MISRA-C:2004 Rule 19.16:
     Unrecognized preprocessing directive has been ignored because of conditional inclusion directives.
     Justification: The preprocessing directive is a warning that indicates a special build 
     configuration which is not suitable for production software. */
  /* PRQA S 3115 1 */
  #warning CAN_CFG_MESSAGE_RAM_BASE_PTR_1 is overridden by the environment. This is not intended for production software!
#endif

/** Base address of the CAN FD controller's registers.
    
    The macro can be overridden by the integrator via command line parameter.
    Doing so is at own risk! */
#ifndef CAN_CFG_REGISTER_BASE_ADDRESS_1
  #define CAN_CFG_REGISTER_BASE_ADDRESS_1 0xb06d0000u
#else
  /* Deviation from MISRA-C:2004 Rule 19.16:
     Unrecognized preprocessing directive has been ignored because of conditional inclusion directives.
     Justification: The preprocessing directive is a warning that indicates a special build 
     configuration which is not suitable for production software. */
  /* PRQA S 3115 1 */
  #warning CAN_CFG_REGISTER_BASE_ADDRESS_1 is overridden by the environment. This is not intended for production software!
#endif


/*  Message RAM (0xb06d8000) linking table:

    Item                     | Size in elements | Start offset | Size in bytes
    -------------------------+------------------+--------------+--------------
    Standard (11bit) filters |                1 |          0x0 |           0x4
    Extended (29bit) filters |                0 |          0x4 |           0x0
    RX FIFO 0                |                0 |          0x4 |           0x0
    RX FIFO 1                |                0 |          0x4 |           0x0
    RX dedicated buffers     |                1 |          0x4 |          0x48
    Event FIFO               |                1 |         0x4c |           0x8
    TX dedicated buffers     |                1 |         0x54 |          0x48
    TX FIFO                  |                0 |         0x9c |           0x0
    unused                   |              na. |         0x9c |        0x3f64
 */
    
/** Part of the initializer to the constant array of controllers. */
#define CAN_CFG_CONTROLLER_1 \
{\
  /* Pointer to an array of baudrates. */\
  .BaudratesCfgPtr = &(Can_Baudrates[1u]), /* CONSTP2(Can_ControllerBaudrateConfigType, TYPEDEF, TYPEDEF) */\
  \
  /* Id of the controller. */\
  .ControllerId = 1u, /* CONST(Can_ControllerIdType, TYPEDEF) */\
  \
  /* Pointer to the default baudrate setting. */\
  .DefaultBaudratePtr = &(Can_Baudrates[1u]), /* CONSTP2(Can_ControllerBaudrateConfigType, TYPEDEF, TYPEDEF) */\
  \
  /* Configuration of the TX Event FIFO. The FIFO element size is ignored, because  */\
  /* it is fixed to 8 bytes. */\
  .EventFifo = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 1u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_8, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0x4cu /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Address offset to the message RAM base address where the filters for extended */\
  /* messages shall be located. */\
  .FiltersExtendedAddressOffset = 0x4u, /* CONST(uint16, TYPEDEF) */\
  \
  /* Address offset to the message RAM base address where the filters for standard */\
  /* messages shall be located. */\
  .FiltersStandardAddressOffset = 0x0u, /* CONST(uint16, TYPEDEF) */\
  \
  /* Specifies if bus-off handling shall be done in interrupt mode (TRUE) or polling */\
  /* mode (FALSE). */\
  .InterruptEnableBusOff = TRUE, /* CONST(boolean, TYPEDEF) */\
  \
  /* Specifies if RX handling shall be done in interrupt mode (TRUE) or polling mode */\
  /* (FALSE). */\
  .InterruptEnableRx = TRUE, /* CONST(boolean, TYPEDEF) */\
  \
  /* Specifies if TX handling shall be done in interrupt mode (TRUE) or polling mode */\
  /* (FALSE). */\
  .InterruptEnableTx = TRUE, /* CONST(boolean, TYPEDEF) */\
  \
  /* Specifies if wakeup handling shall be done in interrupt mode (TRUE) or polling */\
  /* mode (FALSE). */\
  .InterruptEnableWakeup = TRUE, /* CONST(boolean, TYPEDEF) */\
  \
  /* Pointer to the base address of the Message RAM. It must point to the hardware */\
  /* base address, even if the beginning of the message RAM is not used by this */\
  /* controller. */\
  .MessageRamBasePtr = CAN_CFG_MESSAGE_RAM_BASE_PTR_1, /* CONSTP2VAR(uint8, TYPEDEF, TYPEDEF) */\
  \
  /* Number of baudrates in the array of baudrates pointed to by BaudratesCfgPtr. */\
  .NumberOfBaudrates = 1u, /* CONST(uint8, TYPEDEF) */\
  \
  /* Base address of the CAN FD controller's registers. */\
  .RegisterBaseAddress = CAN_CFG_REGISTER_BASE_ADDRESS_1, /* CONST(uint32, TYPEDEF) */\
  \
  /* Configuration of the dedicated RX buffers. The ElementCount equals the number */\
  /* of filter settings in the filter settings list. */\
  .RxBuffers = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 1u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_64, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0x4u /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Pointer to an array of CAN IDs. There is one ID per dedicated RX buffer; the */\
  /* order is the same as the buffers (same index).  */\
  .RxBuffersFiltersPtr = &(Can_DedicatedRxIds[45u]), /* P2CONST(uint32, TYPEDEF, TYPEDEF) */\
  \
  /* Configuration of the RX FIFO 0. */\
  .RxFifo0 = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 0u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_64, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0x4u /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Pointer to an array of different Can filter settings for the RX FIFO 0 */\
  .RxFifo0FiltersPtr = (P2CONST(Can_ControllerFilterType, AUTOMATIC, AUTOMATIC))NULL_PTR, /* P2CONST(Can_ControllerFilterType, TYPEDEF, TYPEDEF) */\
  \
  /* Number of RxFifo0 filters stored in array RxFifo0FiltersPtr. */\
  .RxFifo0FilterElementCount = 0u, /* CONST(uint8, TYPEDEF) */\
  /* Configuration of the RX FIFO 1. */\
  .RxFifo1 = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 0u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_64, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0x4u /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Pointer to an array of different Can filter settings for the RX FIFO 1 */\
  .RxFifo1FiltersPtr = (P2CONST(Can_ControllerFilterType, AUTOMATIC, AUTOMATIC))NULL_PTR, /* P2CONST(Can_ControllerFilterType, TYPEDEF, TYPEDEF) */\
  \
  /* Number of RxFifo1 filters stored in array RxFifo1FiltersPtr. */\
  .RxFifo1FilterElementCount = 0u, /* CONST(uint8, TYPEDEF) */\
  /* Configuration of the dedicated TX buffers. */\
  .TxBuffers = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 1u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_64, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0x54u /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Configuration of the TX FIFO element count. The FIFO element size and start */\
  /* offset are shared with the dedicated TX Buffers. */\
  .TxFifoElementCount = 0u, /* CONST(uint8, TYPEDEF) */\
  \
  /* The wakeup source id that is passed to EcuM_CheckWakeup. */\
  .WakeupSource = 1uL << 5u /* CONST(uint32, TYPEDEF) */\
},\


/** Initializer to the constant array of baudrates. */
#define CAN_CFG_BAUDRATES \
{\
  CAN_CFG_BAUDRATES_0\
  CAN_CFG_BAUDRATES_1\
}

/** Initializer to the constant array of controllers. */
#define CAN_CFG_CONTROLLERS \
{\
  CAN_CFG_CONTROLLER_0\
  CAN_CFG_CONTROLLER_1\
}

/** Initializer to the constant array of dedicated RX IDs. */
#define CAN_CFG_DEDICATED_RX_IDS \
{\
  CAN_CFG_DEDICATED_RX_IDS_0\
  CAN_CFG_DEDICATED_RX_IDS_1\
}

/** Initializer to the constant array of RX FIFO Filters. */
#define CAN_CFG_RX_FIFO_FILTERS \
{\
  CAN_CFG_RX_FIFO_FILTERS_0\
  CAN_CFG_RX_FIFO_FILTERS_1\
}


/** Initializer to the constant array of HRHs.
    The list must be sorted ascending by controller index and for the
    same controller index ascending by buffer index, FIFOs last. */
#define CAN_CFG_HRH_FILTERS \
{\
  CAN_CFG_HRH_FILTERS_0\
  CAN_CFG_HRH_FILTERS_1\
}

/** Initializer to the constant array of HTHs. 
    The list must be sorted ascending by CanObjectId. */
#define CAN_CFG_HTHS \
{\
/* Can_TxHandleMappingType */\
  /* The index of the controller where the HTH is allocated. */\
  /* VAR(Can_ControllerIdType, TYPEDEF) ControllerIndex, */\
  /* |       The index pointed to right position in the Message Queue. */\
  /* |       VAR(uint32, TYPEDEF) QueueStartIndex, */\
  /* |       |       The length of the Object message queue.*/\
  /* |       |       VAR(uint32, TYPEDEF) QueueLength, */\
  /* |       |       |      Enables the possibility to request the data for this HW object with the */\
  /* |       |       |      CanIf_TriggerTransmit from CanIf instead of getting the data by call of */\
  /* |       |       |      Can_Write. */\
  /* |       |       |      VAR(boolean, TYPEDEF) TriggerTransmitEnable, */\
  /* |       |       |      |     Value to initialize unused bytes in a transmit message, when the     */\
  /* |       |       |      |     PduInfo->SduLength does not match possible DLC values and the driver */\
  /* |       |       |      |     have to use the next higher valid DLC for transmission. */\
  /* |       |       |      |     VAR(uint8, TYPEDEF) PaddingValue, */\
  /* |       |       |      |     |     This is the index of the buffer in scope of the controller, */\
  /* |       |       |      |     |     where the HTH is allocated. */\
  /* |       |       |      |     |     0..CAN_CONTROLLER_TX_BUFFER_MAX is a dedicated buffer, */\
  /* |       |       |      |     |     CAN_CONTROLLER_TX_FIFO is the FIFO. */\
  /* |       |       |      |     |     VAR(uint8, TYPEDEF) TxHandle */\
  /* |       |       |      |     |     |    */\
  /* V       V       V      V     V     V    */\
  { 1u,     0u,     1u, FALSE, 255u,  0u },                    /* Array index 0, dedicated TX buffer */\
  { 0u,     1u,     1u, FALSE, 255u,  0u },                    /* Array index 1, dedicated TX buffer */\
  { 0u,     2u,     1u, FALSE, 255u,  1u },                    /* Array index 2, dedicated TX buffer */\
  { 0u,     3u,     1u, FALSE, 255u,  2u },                    /* Array index 3, dedicated TX buffer */\
  { 0u,     4u,     1u, FALSE, 255u,  3u },                    /* Array index 4, dedicated TX buffer */\
  { 0u,     5u,     1u, FALSE, 255u,  4u },                    /* Array index 5, dedicated TX buffer */\
  { 0u,     6u,     1u, FALSE, 255u,  5u },                    /* Array index 6, dedicated TX buffer */\
  { 0u,     7u,     1u, FALSE, 255u,  6u },                    /* Array index 7, dedicated TX buffer */\
}

/** The number of baudrates that are configured. */
#define CAN_CFG_NUMBER_OF_BAUDRATES 2u

/** The number of controllers that are configured. */
#define CAN_CFG_NUMBER_OF_CONTROLLERS 2u

/** The number of dedicated RX objects that are configured. */
#define CAN_CFG_NUMBER_OF_DEDICATED_RX_IDS 46u

/** The number of filters for RX FIFO CAN objects. */
#define CAN_CFG_NUMBER_OF_RX_FIFO_FILTERS 1u

/** The number of configured HRH filters. */
#define CAN_CFG_NUMBER_OF_HRH_FILTERS 47u

/** The number of HRHs are configured. */
#define CAN_CFG_NUMBER_OF_HRHS 47u

/** The number of HTHs are configured. */
#define CAN_CFG_NUMBER_OF_HTHS 8u

/** Number of TX buffers that are available in hardware over all CAN controllers. */
#define CAN_CFG_NUMBER_OF_TX_BUFFERS 8u

/** The number of MCAN IP core release IDs in CAN_CFG_SUPPORTED_MACRO_ID_LIST. */
#define CAN_CFG_NUMBER_OF_SUPPORTED_MACRO_IDS 1u

/** Initializer of the Can_HwCompatibilityList. */
#define CAN_CFG_SUPPORTED_MACRO_IDS \
{\
    0x32041218u,\
}\


/** \brief Base address of the CAN prescaler's registers.
    
    The macro can be overridden by the integrator via command line parameter.
    Doing so is at own risk! */
#ifndef CAN_PRESCALER_BASE_ADDRESS
  #define CAN_PRESCALER_BASE_ADDRESS 0xB0688C00uL
#else
  /* Deviation from MISRA-C:2004 Rule 19.16:
     Unrecognized preprocessing directive has been ignored because of conditional inclusion directives.
     Justification: The preprocessing directive is a warning that indicates a special build 
     configuration which is not suitable for production software. */
  /* PRQA S 3115 1 */
  #warning CAN_PRESCALER_BASE_ADDRESS is overridden by the environment. This is not intended for production software!
#endif

/** Initializer to the prescaler constant. */
#define CAN_CFG_PRESCALER \
{ /* Can_PrescalerType */\
  /* This value represents the clock prescaler source clock. Allowed values: 0 */\
  /* (CAN_PRESCALER_SOURCE_PLL) or 1 (CAN_PRESCALER_SOURCE_MAIN). */\
  .ClockSource = CAN_PRESCALER_SOURCE_MAIN, /* CONST(uint8, TYPEDEF) */\
  \
  /* The value represents the clock prescaler division value. Allowed range: 1..64. */\
  .Division = 1u, /* CONST(uint8, TYPEDEF) */\
  \
  /* Base address of the CAN prescaler's registers. */\
  .RegisterBaseAddress = CAN_PRESCALER_BASE_ADDRESS /* CONST(uint32, TYPEDEF) */\
}\


/** The support of the Can_ChangeBaudrate API is optional. If this parameter is set
 to true the Can_ChangeBaudrate API shall be supported. Otherwise the API is not
 supported.  */
/** \brief Specifies if the Can_ChangeBaudrate API is supported */
#define CAN_CHANGE_BAUDRATE_API  STD_OFF

/** The support of the Can_CheckWakeup API is optional. If this parameter is set
 to true the Can_CheckWakeup API shall be supported. Otherwise the API is not
 supported.  */
/** \brief Specifies if the Can_CheckWakeup API is supported */
#define CAN_CHECK_WAKEUP_API  STD_ON

/** Switches the Development Error Notification ON or OFF. */
#define CAN_DEV_ERROR_DETECT  STD_ON

/** This parameter defines the existence and the name of a callout function that is
 called each time an error was detected.
 The function has to have the following parameters: (ModuleId: uint16,
 InstanceId: uint8, ApiId: uint8, ErrorId: uint8) */
#define CAN_ERROR_CALLOUT_FUNCTION ErrorCalloutHandler

/** The support of the Can_GetStatus API is optional. If this parameter is set
 to true the Can_GetStatus API shall be supported. Otherwise the API is not
 supported.  */
/** \brief Specifies if the Can_GetStatus API is supported */
#define CAN_GET_STATUS_API  STD_ON

/** Switches the Can_GetVersionInfo() API ON or OFF. */
#define CAN_GET_VERSION_INFO_API  STD_ON

/** Specifies if hardware cancellation shall be supported. ON or OFF  */
#define CAN_HW_TRANSMIT_CANCELLATION  STD_OFF

/** Enables/disables cancellation of pending PDUs with identical ID.
    Is used as a boolean function parameter. */
#define CAN_IDENTICAL_ID_CANCELLATION  FALSE

/** This parameter defines the existence and the name of a callout function that is
 called after a successful reception of a received CAN Rx L-PDU (usually
 CanIf_RxIndication). If this parameter is omitted (#undef) no callout takes
 place.  */
/* CAN_LPDU_RECEIVE_CALLOUT_FUNCTION is not defined and will not be called. */

/** ID of the OS counter configured as CanCounterRef. */
#define CAN_OS_COUNTER_ID OsCounter_0

/** Switches the parameter list of Can_RxIndication() compliant to ASR 4.0.3 or to ASR 4.2.1. 
 Possible assignable values:
 - CAN_ASR_421_COMPATIBILITY
 - CAN_ASR_403_COMPATIBILITY */
#define CAN_RX_INDICATION_COMPATIBILITY CAN_ASR_403_COMPATIBILITY

/** The support of the Can_SetBaudrate API is optional. If this parameter is set
 to true the Can_SetBaudrate API shall be supported. Otherwise the API is not
 supported.  */
/** \brief Specifies if the Can_SetBaudrate API is supported */
#define CAN_SET_BAUDRATE_API  STD_OFF

/** Specifies the maximum time for blocking function until a timeout is
 detected. Unit is ticks. */
#define CAN_TIMEOUT_DURATION 2000000uL

/** Switches the call of CanIf_TriggerTransmit operation on or off. */
#define CAN_TRIGGER_TRANSMIT_SUPPORT STD_OFF

/*------------------[Cypress module config version identification]---------*/

#if (defined CAN_CFG_MAJOR_VERSION) /* to prevent double declaration */
#error CAN_CFG_MAJOR_VERSION already defined
#endif /* if (defined CAN_CFG_MAJOR_VERSION) */

/** Driver config major version */
#define CAN_CFG_MAJOR_VERSION 1u


#if (defined CAN_CFG_MINOR_VERSION) /* to prevent double declaration */
#error CAN_CFG_MINOR_VERSION already defined
#endif /* if (defined CAN_CFG_MINOR_VERSION) */

/** Driver config minor version */
#define CAN_CFG_MINOR_VERSION 1u


#if (defined CAN_CFG_PATCH_VERSION) /* to prevent double declaration */
#error CAN_CFG_PATCH_VERSION already defined
#endif /* if (defined CAN_CFG_PATCH_VERSION) */

/** Driver config patch version */
#define CAN_CFG_PATCH_VERSION 27u

/*------------------[symbolic names]----------------------------------------*/

/* Deviation from MISRA-C:2004 Rules 1.2, 5.1; REFERENCE - ISO:C90-6.1.2 Identifiers - Implementation Limits:
   Identifier does not differ from other identifier(s) within the specified number of significant characters.
   Justification: The identifiers for symbolic names are specified by AUTOSAR and
   cannot be changed in scope of the implementation of this CAN driver. */
/* PRQA S 0779 EndOfSymbolicNames */

/* Initialization structure according to ECUM182_Conf (not a symbolic name). */
#define CanConfigSet_0 (*((P2CONST(Can_ConfigType, AUTOMATIC, AUTOMATIC))1u))

/* CanController symbolic names */
#define CanConf_CanController_CanController_0                     0u
#define CanConf_CanController_CanController_1                     1u

/* CanHardwareObject symbolic names */
#define CanConf_CanHardwareObject_HRH_BCM_0x313                      0u
#define CanConf_CanHardwareObject_HRH_BCM_0x584                      1u
#define CanConf_CanHardwareObject_HRH_BCM_Door_0x310                 2u
#define CanConf_CanHardwareObject_HRH_BCM_Lamp_0x318                 3u
#define CanConf_CanHardwareObject_HRH_BCM_Power_0x10B                4u
#define CanConf_CanHardwareObject_HRH_BCM_Sts_0x315                  5u
#define CanConf_CanHardwareObject_HRH_EMS_TBOX_0x639                 6u
#define CanConf_CanHardwareObject_HRH_GW_ABS_Sts_0x221               7u
#define CanConf_CanHardwareObject_HRH_GW_DMS_0x4A0                   8u
#define CanConf_CanHardwareObject_HRH_GW_EMS_0x368                   9u
#define CanConf_CanHardwareObject_HRH_GW_EMS_0x636                  10u
#define CanConf_CanHardwareObject_HRH_GW_EMS_Engstatus_0x142        11u
#define CanConf_CanHardwareObject_HRH_GW_EMS_MT_0x108               12u
#define CanConf_CanHardwareObject_HRH_GW_EMS_Power_0x366            13u
#define CanConf_CanHardwareObject_HRH_GW_EMS_Sts_Power_0x151        14u
#define CanConf_CanHardwareObject_HRH_GW_EMS_Torq_0x105             15u
#define CanConf_CanHardwareObject_HRH_GW_EMS_Tq_0x101               16u
#define CanConf_CanHardwareObject_HRH_GW_EMS_WarmLimp_0x364         17u
#define CanConf_CanHardwareObject_HRH_GW_EMS_WhlTorq_0x107          18u
#define CanConf_CanHardwareObject_HRH_GW_EPS_Chassis_0x260          19u
#define CanConf_CanHardwareObject_HRH_GW_ESP_Status_Chassis_0x243   20u
#define CanConf_CanHardwareObject_HRH_GW_IPM_0x245                  21u
#define CanConf_CanHardwareObject_HRH_GW_IPM_LeftLine_0x278         22u
#define CanConf_CanHardwareObject_HRH_GW_IPM_LeftLine_0x280         23u
#define CanConf_CanHardwareObject_HRH_GW_IPM_RightLine_0x490        24u
#define CanConf_CanHardwareObject_HRH_GW_IPM_RightLine_0x491        25u
#define CanConf_CanHardwareObject_HRH_GW_MRR_Chassis_0x246          26u
#define CanConf_CanHardwareObject_HRH_GW_MRR_FRObj_0x480            27u
#define CanConf_CanHardwareObject_HRH_GW_MRR_FrObj_0x279            28u
#define CanConf_CanHardwareObject_HRH_GW_PAM_0x271                  29u
#define CanConf_CanHardwareObject_HRH_GW_SOD_0x275                  30u
#define CanConf_CanHardwareObject_HRH_GW_SWM_Body_0x31A             31u
#define CanConf_CanHardwareObject_HRH_GW_SWM_MRR_0x31B              32u
#define CanConf_CanHardwareObject_HRH_GW_TBOX_time_0x582            33u
#define CanConf_CanHardwareObject_HRH_GW_TCU_GearInfo_Power_0x123   34u
#define CanConf_CanHardwareObject_HRH_GW_TCU_Info_0x395             35u
#define CanConf_CanHardwareObject_HRH_MP5_0x382                     36u
#define CanConf_CanHardwareObject_HRH_MP5_0x384                     37u
#define CanConf_CanHardwareObject_HRH_MP5_0x530                     38u
#define CanConf_CanHardwareObject_HRH_MP5_Windows_0x532             39u
#define CanConf_CanHardwareObject_HRH_PEPS_0x325                    40u
#define CanConf_CanHardwareObject_HRH_PEPS_Start_0x1A5              41u
#define CanConf_CanHardwareObject_HRH_TPMS_Tire_0x361               42u
#define CanConf_CanHardwareObject_HRH_TPMS_Tire_0x362               43u
#define CanConf_CanHardwareObject_HRH_NM                            44u
#define CanConf_CanHardwareObject_HRH_Tester_DiagReqToIC            45u
#define CanConf_CanHardwareObject_HRH_Tester_DiagFuncReq            46u
#define CanConf_CanHardwareObject_HTH_IC_0x386                      47u
#define CanConf_CanHardwareObject_HTH_IC_0x387                      48u
#define CanConf_CanHardwareObject_HTH_IC_0x510                      49u
#define CanConf_CanHardwareObject_HTH_IC_0x525                      50u
#define CanConf_CanHardwareObject_HTH_IC_0x637                      51u
#define CanConf_CanHardwareObject_HTH_IC_time_0x581                 52u
#define CanConf_CanHardwareObject_HTH_IC_NM_0x430                   53u
#define CanConf_CanHardwareObject_HTH_IC_DiagResp                   54u

/* PRQA L:EndOfSymbolicNames */

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

#define CAN_START_SEC_CODE
/* MISRA-C:2004 Rule 19.1 deviation: MemMap.h must be included in-line. */ /* PRQA S 5087 1 */
#include "MemMap.h"

/** \brief Can_Interrupt_CAN1_Cat1
 **
 ** Category 1 interrupt service handler for controller CAN1.
 **
 */
extern ISR_NATIVE(Can_Interrupt_CAN1_Cat1);

/** \brief Can_Interrupt_CAN1_Cat2
 **
 ** Category 2 interrupt service handler for controller CAN1.
 **
 */
extern ISR(Can_Interrupt_CAN1_Cat2);

/** \brief Can_Interrupt_CAN6_Cat1
 **
 ** Category 1 interrupt service handler for controller CAN6.
 **
 */
extern ISR_NATIVE(Can_Interrupt_CAN6_Cat1);

/** \brief Can_Interrupt_CAN6_Cat2
 **
 ** Category 2 interrupt service handler for controller CAN6.
 **
 */
extern ISR(Can_Interrupt_CAN6_Cat2);

#define CAN_STOP_SEC_CODE
/* MISRA-C:2004 Rule 19.1 deviation: MemMap.h must be included in-line. */ /* PRQA S 5087 1 */
#include "MemMap.h"

#endif /**defined(CAN_CFG_H_INCLUDED)*/

/*==================[end of file]===========================================*/
